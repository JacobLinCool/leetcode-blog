<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode Story</title><link>https://jacoblincool.github.io/leetcode-blog/</link><description>Recent content on Leetcode Story</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Tue, 08 Jun 2021 18:00:00 +0800</lastBuildDate><atom:link href="https://jacoblincool.github.io/leetcode-blog/index.xml" rel="self" type="application/rss+xml"/><item><title>105. Construct Binary Tree from Preorder and Inorder Traversal</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0105/</link><pubDate>Tue, 08 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0105/</guid><description>Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal
題目 Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
想法 用前序遍歷及中序遍歷的結果反推二元樹的結構。
前序遍歷 (pre-order) 就是先去根節點，再去左節點，最後右節點。
中序遍歷 (in-order) 則是先去左節點，再去根節點，最後右節點。
二元樹的特色是：每個節點及其子節點都是二元樹。
所以我們可以從最上面的根節點，分左右遞迴建置子樹。
依前序遍歷的特性可以知道 preorder[0] 就是根節點（的值）。
依該值去反查 inorder[x]，則 inorder[x - 1] 就會是它的左子節點（的值），而 inorder[x + 1] 則會是它的右子節點（的值）。
以左右子節點為子樹的根節點，遞迴下去建立子樹，最後回傳最上面的根節點就可以了。
實作 Javascript</description></item><item><title>746. Min Cost Climbing Stairs</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0746/</link><pubDate>Mon, 07 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0746/</guid><description>Leetcode 746. Min Cost Climbing Stairs
題目 You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.
You can either start from the step with index 0, or the step with index 1.
Return the minimum cost to reach the top of the floor.
想法 這個階梯問題最一般的方法應該會是用 DP 來做。
因為到第 x 階所要花的總 cost 就會是到第 x - 1 階（最後再跨 1 步到 x）或到第 x - 2 階（最後再跨 2 步到 x）兩者之間的較小總 cost 再加上第 x 階自己的 cost。</description></item><item><title>128. Longest Consecutive Sequence</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0128/</link><pubDate>Sun, 06 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0128/</guid><description>Leetcode 128. Longest Consecutive Sequence
題目 Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
想法 這題是要從一堆沒有規則並且可能會重複數字中，找最長的連續數字串的長度。
因為 Set 有不重複的特性，可以用來處理重複的問題，而且找指定數字時只要 O(1) 時間，所以我們用 Set 來做。
做法很單純，遍歷 nums set，我們只從每一串最小數字開始找起，串中數字就跳過，因為必定會算過，不必重複算。
實作 Javascript
var longestConsecutive = function(nums) { // max 存最大長度 let max = 0; // 用 Set 來去重複，且找指定數字時只要 O(1) const nums_set = new Set(nums); for(let num of nums_set) { // 如果 Set 中有比這個 num 小的，代表我們已經找過這串了，跳過 if(nums_set.</description></item><item><title>1383. Maximum Performance of a Team</title><link>https://jacoblincool.github.io/leetcode-blog/posts/1383/</link><pubDate>Sat, 05 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/1383/</guid><description>Leetcode 1383. Maximum Performance of a Team
題目 You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.
Choose at most k different engineers out of the n engineers to form a team with the maximum performance.
The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.</description></item><item><title>752. Open the Lock</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0752/</link><pubDate>Fri, 04 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0752/</guid><description>Leetcode 752. Open the Lock
題目 You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot.
The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description></item><item><title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title><link>https://jacoblincool.github.io/leetcode-blog/posts/1465/</link><pubDate>Thu, 03 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/1465/</guid><description>Leetcode 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
題目 You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:
horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.</description></item><item><title>97. Interleaving String</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0097/</link><pubDate>Wed, 02 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0097/</guid><description>Leetcode 97. Interleaving String
題目 Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.
An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:
s = s1 + s2 + &amp;hellip; + sn t = t1 + t2 + &amp;hellip; + tm |n - m| &amp;lt;= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + &amp;hellip; or t1 + s1 + t2 + s2 + t3 + s3 + &amp;hellip; Note: a + b is the concatenation of strings a and b.</description></item><item><title>695. Max Area of Island</title><link>https://jacoblincool.github.io/leetcode-blog/posts/0695/</link><pubDate>Tue, 01 Jun 2021 18:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/0695/</guid><description>Leetcode 695. Max Area of Island
題目 You are given an m x n binary matrix grid.
An island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.)
You may assume all four edges of the grid are surrounded by water.
The area of an island is the number of cells with a value 1 in the island.
Return the maximum area of an island in grid. If there is no island, return 0.</description></item><item><title>起始之地</title><link>https://jacoblincool.github.io/leetcode-blog/posts/start/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0800</pubDate><guid>https://jacoblincool.github.io/leetcode-blog/posts/start/</guid><description>故事的開始 Leetcode 是一個蒐集資訊產業面試題目的網站，上面有非常多不同類型的題目，包括演算法、資料庫、Shell、平行運算等。
這個部落格主要是用來記錄各種題目的解法。
目前規劃是希望能寫完 June Challenge 30 篇。</description></item></channel></rss>